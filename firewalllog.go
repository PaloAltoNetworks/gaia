// Code generated by elegen. DO NOT EDIT.
// Source: go.aporeto.io/elemental (templates/model.gotpl)

package gaia

import (
	"fmt"

	"github.com/globalsign/mgo/bson"
	"github.com/mitchellh/copystructure"
	"go.aporeto.io/elemental"
)

// FirewallLogIdentity represents the Identity of the object.
var FirewallLogIdentity = elemental.Identity{
	Name:     "firewalllog",
	Category: "firewalllogs",
	Package:  "pcfw",
	Private:  false,
}

// FirewallLogsList represents a list of FirewallLogs
type FirewallLogsList []*FirewallLog

// Identity returns the identity of the objects in the list.
func (o FirewallLogsList) Identity() elemental.Identity {

	return FirewallLogIdentity
}

// Copy returns a pointer to a copy the FirewallLogsList.
func (o FirewallLogsList) Copy() elemental.Identifiables {

	out := append(FirewallLogsList{}, o...)
	return &out
}

// Append appends the objects to the a new copy of the FirewallLogsList.
func (o FirewallLogsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(FirewallLogsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*FirewallLog))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o FirewallLogsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o FirewallLogsList) DefaultOrder() []string {

	return []string{}
}

// ToSparse returns the FirewallLogsList converted to SparseFirewallLogsList.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o FirewallLogsList) ToSparse(fields ...string) elemental.Identifiables {

	out := make(SparseFirewallLogsList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToSparse(fields...).(*SparseFirewallLog)
	}

	return out
}

// Version returns the version of the content.
func (o FirewallLogsList) Version() int {

	return 1
}

// FirewallLog represents the model of a firewalllog
type FirewallLog struct {
	// The IP address of the user who requested the web page or the IP address of the
	// next to last device that the request traversed. If the request goes through one
	// or more proxies, load balancers, or other upstream devices, the firewall
	// displays the IP address of the most recent device.
	XFFIP string `json:"XFFIP" msgpack:"XFFIP" bson:"-" mapstructure:"XFFIP,omitempty"`

	// Action taken for the session.
	Action string `json:"action" msgpack:"action" bson:"-" mapstructure:"action,omitempty"`

	// Application associated with the session.
	App string `json:"app" msgpack:"app" bson:"-" mapstructure:"app,omitempty"`

	// Application category associated with the session.
	AppCategory string `json:"appCategory" msgpack:"appCategory" bson:"-" mapstructure:"appCategory,omitempty"`

	// Application subcategory associated with the session.
	AppSubcategory string `json:"appSubcategory" msgpack:"appSubcategory" bson:"-" mapstructure:"appSubcategory,omitempty"`

	// Number of bytes in the server-to-client direction of the session.
	BytesReceived string `json:"bytesReceived" msgpack:"bytesReceived" bson:"-" mapstructure:"bytesReceived,omitempty"`

	// Number of bytes in the client-to-server direction of the session.
	BytesSent string `json:"bytesSent" msgpack:"bytesSent" bson:"-" mapstructure:"bytesSent,omitempty"`

	// Chain status of the session.
	ChainStatus string `json:"chainStatus" msgpack:"chainStatus" bson:"-" mapstructure:"chainStatus,omitempty"`

	// Cloud account associated with the session.
	CloudAccount string `json:"cloudAccount" msgpack:"cloudAccount" bson:"-" mapstructure:"cloudAccount,omitempty"`

	// Cloud provider region associated with the session.
	CloudRegion string `json:"cloudRegion" msgpack:"cloudRegion" bson:"-" mapstructure:"cloudRegion,omitempty"`

	// Cloud provider associated with the session.
	CloudType string `json:"cloudType" msgpack:"cloudType" bson:"-" mapstructure:"cloudType,omitempty"`

	// Destination country or Internal region for private addresses. Maximum length is
	// 32 bytes.
	DestinationCountry string `json:"destinationCountry" msgpack:"destinationCountry" bson:"-" mapstructure:"destinationCountry,omitempty"`

	// Original session destination IP address.
	DestinationIP string `json:"destinationIP" msgpack:"destinationIP" bson:"-" mapstructure:"destinationIP,omitempty"`

	// Destination port utilized by the session.
	DestinationPort int `json:"destinationPort" msgpack:"destinationPort" bson:"-" mapstructure:"destinationPort,omitempty"`

	// Name of firewall that generated the log.
	FirewallName string `json:"firewallName" msgpack:"firewallName" bson:"-" mapstructure:"firewallName,omitempty"`

	// Operation mode of firewall that generated the log.
	OperationMode string `json:"operationMode" msgpack:"operationMode" bson:"-" mapstructure:"operationMode,omitempty"`

	// Number of server-to-client packets for the session.
	PacketsReceived string `json:"packetsReceived" msgpack:"packetsReceived" bson:"-" mapstructure:"packetsReceived,omitempty"`

	// Number of client-to-server packets for the session.
	PacketsSent string `json:"packetsSent" msgpack:"packetsSent" bson:"-" mapstructure:"packetsSent,omitempty"`

	// IP protocol associated with the session.
	Protocol string `json:"protocol" msgpack:"protocol" bson:"-" mapstructure:"protocol,omitempty"`

	// Type of decryption proxy associated with the session.
	ProxyType string `json:"proxyType" msgpack:"proxyType" bson:"-" mapstructure:"proxyType,omitempty"`

	// Name of the rule that the session matched.
	Rule string `json:"rule" msgpack:"rule" bson:"-" mapstructure:"rule,omitempty"`

	// The reason a session terminated. If the termination had multiple causes, this
	// field displays only the highest priority reason.
	SessionEndReason string `json:"sessionEndReason" msgpack:"sessionEndReason" bson:"-" mapstructure:"sessionEndReason,omitempty"`

	// Server Name Indication (SNI) value for the session.
	Sni string `json:"sni" msgpack:"sni" bson:"-" mapstructure:"sni,omitempty"`

	// Source country or Internal region for private addresses; maximum length is 32
	// bytes.
	SourceCountry string `json:"sourceCountry" msgpack:"sourceCountry" bson:"-" mapstructure:"sourceCountry,omitempty"`

	// Original session source IP address.
	SourceIP string `json:"sourceIP" msgpack:"sourceIP" bson:"-" mapstructure:"sourceIP,omitempty"`

	// Source port utilized by the session.
	SourcePort int `json:"sourcePort" msgpack:"sourcePort" bson:"-" mapstructure:"sourcePort,omitempty"`

	// Describes threat categories used to classify different types of threat
	// signatures.
	ThreatCategory string `json:"threatCategory" msgpack:"threatCategory" bson:"-" mapstructure:"threatCategory,omitempty"`

	// Indicates the direction of the attack, client-to-server or server-to-client.
	ThreatDirection string `json:"threatDirection" msgpack:"threatDirection" bson:"-" mapstructure:"threatDirection,omitempty"`

	// Name of the threat signature that triggered the session.
	ThreatName string `json:"threatName" msgpack:"threatName" bson:"-" mapstructure:"threatName,omitempty"`

	// Severity associated with the threat; values are informational, low, medium,
	// high, critical.
	ThreatSeverity string `json:"threatSeverity" msgpack:"threatSeverity" bson:"-" mapstructure:"threatSeverity,omitempty"`

	// TLS version associated with the session.
	TlsVersion string `json:"tlsVersion" msgpack:"tlsVersion" bson:"-" mapstructure:"tlsVersion,omitempty"`

	// URL category associated with the session (if applicable).
	UrlCategory string `json:"urlCategory" msgpack:"urlCategory" bson:"-" mapstructure:"urlCategory,omitempty"`

	// Service endpoint associated with the session.
	VpcEndpoint string `json:"vpcEndpoint" msgpack:"vpcEndpoint" bson:"-" mapstructure:"vpcEndpoint,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewFirewallLog returns a new *FirewallLog
func NewFirewallLog() *FirewallLog {

	return &FirewallLog{
		ModelVersion: 1,
	}
}

// Identity returns the Identity of the object.
func (o *FirewallLog) Identity() elemental.Identity {

	return FirewallLogIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *FirewallLog) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *FirewallLog) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *FirewallLog) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesFirewallLog{}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *FirewallLog) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesFirewallLog{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *FirewallLog) Version() int {

	return 1
}

// BleveType implements the bleve.Classifier Interface.
func (o *FirewallLog) BleveType() string {

	return "firewalllog"
}

// DefaultOrder returns the list of default ordering fields.
func (o *FirewallLog) DefaultOrder() []string {

	return []string{}
}

// Doc returns the documentation for the object
func (o *FirewallLog) Doc() string {

	return `Represents a log line in a log query result.`
}

func (o *FirewallLog) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *FirewallLog) ToSparse(fields ...string) elemental.SparseIdentifiable {

	if len(fields) == 0 {
		// nolint: goimports
		return &SparseFirewallLog{
			XFFIP:              &o.XFFIP,
			Action:             &o.Action,
			App:                &o.App,
			AppCategory:        &o.AppCategory,
			AppSubcategory:     &o.AppSubcategory,
			BytesReceived:      &o.BytesReceived,
			BytesSent:          &o.BytesSent,
			ChainStatus:        &o.ChainStatus,
			CloudAccount:       &o.CloudAccount,
			CloudRegion:        &o.CloudRegion,
			CloudType:          &o.CloudType,
			DestinationCountry: &o.DestinationCountry,
			DestinationIP:      &o.DestinationIP,
			DestinationPort:    &o.DestinationPort,
			FirewallName:       &o.FirewallName,
			OperationMode:      &o.OperationMode,
			PacketsReceived:    &o.PacketsReceived,
			PacketsSent:        &o.PacketsSent,
			Protocol:           &o.Protocol,
			ProxyType:          &o.ProxyType,
			Rule:               &o.Rule,
			SessionEndReason:   &o.SessionEndReason,
			Sni:                &o.Sni,
			SourceCountry:      &o.SourceCountry,
			SourceIP:           &o.SourceIP,
			SourcePort:         &o.SourcePort,
			ThreatCategory:     &o.ThreatCategory,
			ThreatDirection:    &o.ThreatDirection,
			ThreatName:         &o.ThreatName,
			ThreatSeverity:     &o.ThreatSeverity,
			TlsVersion:         &o.TlsVersion,
			UrlCategory:        &o.UrlCategory,
			VpcEndpoint:        &o.VpcEndpoint,
		}
	}

	sp := &SparseFirewallLog{}
	for _, f := range fields {
		switch f {
		case "XFFIP":
			sp.XFFIP = &(o.XFFIP)
		case "action":
			sp.Action = &(o.Action)
		case "app":
			sp.App = &(o.App)
		case "appCategory":
			sp.AppCategory = &(o.AppCategory)
		case "appSubcategory":
			sp.AppSubcategory = &(o.AppSubcategory)
		case "bytesReceived":
			sp.BytesReceived = &(o.BytesReceived)
		case "bytesSent":
			sp.BytesSent = &(o.BytesSent)
		case "chainStatus":
			sp.ChainStatus = &(o.ChainStatus)
		case "cloudAccount":
			sp.CloudAccount = &(o.CloudAccount)
		case "cloudRegion":
			sp.CloudRegion = &(o.CloudRegion)
		case "cloudType":
			sp.CloudType = &(o.CloudType)
		case "destinationCountry":
			sp.DestinationCountry = &(o.DestinationCountry)
		case "destinationIP":
			sp.DestinationIP = &(o.DestinationIP)
		case "destinationPort":
			sp.DestinationPort = &(o.DestinationPort)
		case "firewallName":
			sp.FirewallName = &(o.FirewallName)
		case "operationMode":
			sp.OperationMode = &(o.OperationMode)
		case "packetsReceived":
			sp.PacketsReceived = &(o.PacketsReceived)
		case "packetsSent":
			sp.PacketsSent = &(o.PacketsSent)
		case "protocol":
			sp.Protocol = &(o.Protocol)
		case "proxyType":
			sp.ProxyType = &(o.ProxyType)
		case "rule":
			sp.Rule = &(o.Rule)
		case "sessionEndReason":
			sp.SessionEndReason = &(o.SessionEndReason)
		case "sni":
			sp.Sni = &(o.Sni)
		case "sourceCountry":
			sp.SourceCountry = &(o.SourceCountry)
		case "sourceIP":
			sp.SourceIP = &(o.SourceIP)
		case "sourcePort":
			sp.SourcePort = &(o.SourcePort)
		case "threatCategory":
			sp.ThreatCategory = &(o.ThreatCategory)
		case "threatDirection":
			sp.ThreatDirection = &(o.ThreatDirection)
		case "threatName":
			sp.ThreatName = &(o.ThreatName)
		case "threatSeverity":
			sp.ThreatSeverity = &(o.ThreatSeverity)
		case "tlsVersion":
			sp.TlsVersion = &(o.TlsVersion)
		case "urlCategory":
			sp.UrlCategory = &(o.UrlCategory)
		case "vpcEndpoint":
			sp.VpcEndpoint = &(o.VpcEndpoint)
		}
	}

	return sp
}

// Patch apply the non nil value of a *SparseFirewallLog to the object.
func (o *FirewallLog) Patch(sparse elemental.SparseIdentifiable) {
	if !sparse.Identity().IsEqual(o.Identity()) {
		panic("cannot patch from a parse with different identity")
	}

	so := sparse.(*SparseFirewallLog)
	if so.XFFIP != nil {
		o.XFFIP = *so.XFFIP
	}
	if so.Action != nil {
		o.Action = *so.Action
	}
	if so.App != nil {
		o.App = *so.App
	}
	if so.AppCategory != nil {
		o.AppCategory = *so.AppCategory
	}
	if so.AppSubcategory != nil {
		o.AppSubcategory = *so.AppSubcategory
	}
	if so.BytesReceived != nil {
		o.BytesReceived = *so.BytesReceived
	}
	if so.BytesSent != nil {
		o.BytesSent = *so.BytesSent
	}
	if so.ChainStatus != nil {
		o.ChainStatus = *so.ChainStatus
	}
	if so.CloudAccount != nil {
		o.CloudAccount = *so.CloudAccount
	}
	if so.CloudRegion != nil {
		o.CloudRegion = *so.CloudRegion
	}
	if so.CloudType != nil {
		o.CloudType = *so.CloudType
	}
	if so.DestinationCountry != nil {
		o.DestinationCountry = *so.DestinationCountry
	}
	if so.DestinationIP != nil {
		o.DestinationIP = *so.DestinationIP
	}
	if so.DestinationPort != nil {
		o.DestinationPort = *so.DestinationPort
	}
	if so.FirewallName != nil {
		o.FirewallName = *so.FirewallName
	}
	if so.OperationMode != nil {
		o.OperationMode = *so.OperationMode
	}
	if so.PacketsReceived != nil {
		o.PacketsReceived = *so.PacketsReceived
	}
	if so.PacketsSent != nil {
		o.PacketsSent = *so.PacketsSent
	}
	if so.Protocol != nil {
		o.Protocol = *so.Protocol
	}
	if so.ProxyType != nil {
		o.ProxyType = *so.ProxyType
	}
	if so.Rule != nil {
		o.Rule = *so.Rule
	}
	if so.SessionEndReason != nil {
		o.SessionEndReason = *so.SessionEndReason
	}
	if so.Sni != nil {
		o.Sni = *so.Sni
	}
	if so.SourceCountry != nil {
		o.SourceCountry = *so.SourceCountry
	}
	if so.SourceIP != nil {
		o.SourceIP = *so.SourceIP
	}
	if so.SourcePort != nil {
		o.SourcePort = *so.SourcePort
	}
	if so.ThreatCategory != nil {
		o.ThreatCategory = *so.ThreatCategory
	}
	if so.ThreatDirection != nil {
		o.ThreatDirection = *so.ThreatDirection
	}
	if so.ThreatName != nil {
		o.ThreatName = *so.ThreatName
	}
	if so.ThreatSeverity != nil {
		o.ThreatSeverity = *so.ThreatSeverity
	}
	if so.TlsVersion != nil {
		o.TlsVersion = *so.TlsVersion
	}
	if so.UrlCategory != nil {
		o.UrlCategory = *so.UrlCategory
	}
	if so.VpcEndpoint != nil {
		o.VpcEndpoint = *so.VpcEndpoint
	}
}

// DeepCopy returns a deep copy if the FirewallLog.
func (o *FirewallLog) DeepCopy() *FirewallLog {

	if o == nil {
		return nil
	}

	out := &FirewallLog{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *FirewallLog.
func (o *FirewallLog) DeepCopyInto(out *FirewallLog) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy FirewallLog: %s", err))
	}

	*out = *target.(*FirewallLog)
}

// Validate valides the current information stored into the structure.
func (o *FirewallLog) Validate() error {

	errors := elemental.Errors{}
	requiredErrors := elemental.Errors{}

	if len(requiredErrors) > 0 {
		return requiredErrors
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*FirewallLog) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	if v, ok := FirewallLogAttributesMap[name]; ok {
		return v
	}

	// We could not find it, so let's check on the lower case indexed spec map
	return FirewallLogLowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*FirewallLog) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return FirewallLogAttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *FirewallLog) ValueForAttribute(name string) any {

	switch name {
	case "XFFIP":
		return o.XFFIP
	case "action":
		return o.Action
	case "app":
		return o.App
	case "appCategory":
		return o.AppCategory
	case "appSubcategory":
		return o.AppSubcategory
	case "bytesReceived":
		return o.BytesReceived
	case "bytesSent":
		return o.BytesSent
	case "chainStatus":
		return o.ChainStatus
	case "cloudAccount":
		return o.CloudAccount
	case "cloudRegion":
		return o.CloudRegion
	case "cloudType":
		return o.CloudType
	case "destinationCountry":
		return o.DestinationCountry
	case "destinationIP":
		return o.DestinationIP
	case "destinationPort":
		return o.DestinationPort
	case "firewallName":
		return o.FirewallName
	case "operationMode":
		return o.OperationMode
	case "packetsReceived":
		return o.PacketsReceived
	case "packetsSent":
		return o.PacketsSent
	case "protocol":
		return o.Protocol
	case "proxyType":
		return o.ProxyType
	case "rule":
		return o.Rule
	case "sessionEndReason":
		return o.SessionEndReason
	case "sni":
		return o.Sni
	case "sourceCountry":
		return o.SourceCountry
	case "sourceIP":
		return o.SourceIP
	case "sourcePort":
		return o.SourcePort
	case "threatCategory":
		return o.ThreatCategory
	case "threatDirection":
		return o.ThreatDirection
	case "threatName":
		return o.ThreatName
	case "threatSeverity":
		return o.ThreatSeverity
	case "tlsVersion":
		return o.TlsVersion
	case "urlCategory":
		return o.UrlCategory
	case "vpcEndpoint":
		return o.VpcEndpoint
	}

	return nil
}

// FirewallLogAttributesMap represents the map of attribute for FirewallLog.
var FirewallLogAttributesMap = map[string]elemental.AttributeSpecification{
	"XFFIP": {
		AllowedChoices: []string{},
		ConvertedName:  "XFFIP",
		Description: `The IP address of the user who requested the web page or the IP address of the
next to last device that the request traversed. If the request goes through one
or more proxies, load balancers, or other upstream devices, the firewall
displays the IP address of the most recent device.`,
		Exposed:  true,
		Name:     "XFFIP",
		ReadOnly: true,
		Type:     "string",
	},
	"Action": {
		AllowedChoices: []string{},
		ConvertedName:  "Action",
		Description:    `Action taken for the session.`,
		Exposed:        true,
		Name:           "action",
		ReadOnly:       true,
		Type:           "string",
	},
	"App": {
		AllowedChoices: []string{},
		ConvertedName:  "App",
		Description:    `Application associated with the session.`,
		Exposed:        true,
		Name:           "app",
		ReadOnly:       true,
		Type:           "string",
	},
	"AppCategory": {
		AllowedChoices: []string{},
		ConvertedName:  "AppCategory",
		Description:    `Application category associated with the session.`,
		Exposed:        true,
		Name:           "appCategory",
		ReadOnly:       true,
		Type:           "string",
	},
	"AppSubcategory": {
		AllowedChoices: []string{},
		ConvertedName:  "AppSubcategory",
		Description:    `Application subcategory associated with the session.`,
		Exposed:        true,
		Name:           "appSubcategory",
		ReadOnly:       true,
		Type:           "string",
	},
	"BytesReceived": {
		AllowedChoices: []string{},
		ConvertedName:  "BytesReceived",
		Description:    `Number of bytes in the server-to-client direction of the session.`,
		Exposed:        true,
		Name:           "bytesReceived",
		ReadOnly:       true,
		Type:           "string",
	},
	"BytesSent": {
		AllowedChoices: []string{},
		ConvertedName:  "BytesSent",
		Description:    `Number of bytes in the client-to-server direction of the session.`,
		Exposed:        true,
		Name:           "bytesSent",
		ReadOnly:       true,
		Type:           "string",
	},
	"ChainStatus": {
		AllowedChoices: []string{},
		ConvertedName:  "ChainStatus",
		Description:    `Chain status of the session.`,
		Exposed:        true,
		Name:           "chainStatus",
		ReadOnly:       true,
		Type:           "string",
	},
	"CloudAccount": {
		AllowedChoices: []string{},
		ConvertedName:  "CloudAccount",
		Description:    `Cloud account associated with the session.`,
		Exposed:        true,
		Name:           "cloudAccount",
		ReadOnly:       true,
		Type:           "string",
	},
	"CloudRegion": {
		AllowedChoices: []string{},
		ConvertedName:  "CloudRegion",
		Description:    `Cloud provider region associated with the session.`,
		Exposed:        true,
		Name:           "cloudRegion",
		ReadOnly:       true,
		Type:           "string",
	},
	"CloudType": {
		AllowedChoices: []string{},
		ConvertedName:  "CloudType",
		Description:    `Cloud provider associated with the session.`,
		Exposed:        true,
		Name:           "cloudType",
		ReadOnly:       true,
		Type:           "string",
	},
	"DestinationCountry": {
		AllowedChoices: []string{},
		ConvertedName:  "DestinationCountry",
		Description: `Destination country or Internal region for private addresses. Maximum length is
32 bytes.`,
		Exposed:  true,
		Name:     "destinationCountry",
		ReadOnly: true,
		Type:     "string",
	},
	"DestinationIP": {
		AllowedChoices: []string{},
		ConvertedName:  "DestinationIP",
		Description:    `Original session destination IP address.`,
		Exposed:        true,
		Name:           "destinationIP",
		ReadOnly:       true,
		Type:           "string",
	},
	"DestinationPort": {
		AllowedChoices: []string{},
		ConvertedName:  "DestinationPort",
		Description:    `Destination port utilized by the session.`,
		Exposed:        true,
		Name:           "destinationPort",
		ReadOnly:       true,
		Type:           "integer",
	},
	"FirewallName": {
		AllowedChoices: []string{},
		ConvertedName:  "FirewallName",
		Description:    `Name of firewall that generated the log.`,
		Exposed:        true,
		Name:           "firewallName",
		ReadOnly:       true,
		Type:           "string",
	},
	"OperationMode": {
		AllowedChoices: []string{},
		ConvertedName:  "OperationMode",
		Description:    `Operation mode of firewall that generated the log.`,
		Exposed:        true,
		Name:           "operationMode",
		ReadOnly:       true,
		Type:           "string",
	},
	"PacketsReceived": {
		AllowedChoices: []string{},
		ConvertedName:  "PacketsReceived",
		Description:    `Number of server-to-client packets for the session.`,
		Exposed:        true,
		Name:           "packetsReceived",
		ReadOnly:       true,
		Type:           "string",
	},
	"PacketsSent": {
		AllowedChoices: []string{},
		ConvertedName:  "PacketsSent",
		Description:    `Number of client-to-server packets for the session.`,
		Exposed:        true,
		Name:           "packetsSent",
		ReadOnly:       true,
		Type:           "string",
	},
	"Protocol": {
		AllowedChoices: []string{},
		ConvertedName:  "Protocol",
		Description:    `IP protocol associated with the session.`,
		Exposed:        true,
		Name:           "protocol",
		ReadOnly:       true,
		Type:           "string",
	},
	"ProxyType": {
		AllowedChoices: []string{},
		ConvertedName:  "ProxyType",
		Description:    `Type of decryption proxy associated with the session.`,
		Exposed:        true,
		Name:           "proxyType",
		ReadOnly:       true,
		Type:           "string",
	},
	"Rule": {
		AllowedChoices: []string{},
		ConvertedName:  "Rule",
		Description:    `Name of the rule that the session matched.`,
		Exposed:        true,
		Name:           "rule",
		ReadOnly:       true,
		Type:           "string",
	},
	"SessionEndReason": {
		AllowedChoices: []string{},
		ConvertedName:  "SessionEndReason",
		Description: `The reason a session terminated. If the termination had multiple causes, this
field displays only the highest priority reason.`,
		Exposed:  true,
		Name:     "sessionEndReason",
		ReadOnly: true,
		Type:     "string",
	},
	"Sni": {
		AllowedChoices: []string{},
		ConvertedName:  "Sni",
		Description:    `Server Name Indication (SNI) value for the session.`,
		Exposed:        true,
		Name:           "sni",
		ReadOnly:       true,
		Type:           "string",
	},
	"SourceCountry": {
		AllowedChoices: []string{},
		ConvertedName:  "SourceCountry",
		Description: `Source country or Internal region for private addresses; maximum length is 32
bytes.`,
		Exposed:  true,
		Name:     "sourceCountry",
		ReadOnly: true,
		Type:     "string",
	},
	"SourceIP": {
		AllowedChoices: []string{},
		ConvertedName:  "SourceIP",
		Description:    `Original session source IP address.`,
		Exposed:        true,
		Name:           "sourceIP",
		ReadOnly:       true,
		Type:           "string",
	},
	"SourcePort": {
		AllowedChoices: []string{},
		ConvertedName:  "SourcePort",
		Description:    `Source port utilized by the session.`,
		Exposed:        true,
		Name:           "sourcePort",
		ReadOnly:       true,
		Type:           "integer",
	},
	"ThreatCategory": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatCategory",
		Description: `Describes threat categories used to classify different types of threat
signatures.`,
		Exposed:  true,
		Name:     "threatCategory",
		ReadOnly: true,
		Type:     "string",
	},
	"ThreatDirection": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatDirection",
		Description:    `Indicates the direction of the attack, client-to-server or server-to-client.`,
		Exposed:        true,
		Name:           "threatDirection",
		ReadOnly:       true,
		Type:           "string",
	},
	"ThreatName": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatName",
		Description:    `Name of the threat signature that triggered the session.`,
		Exposed:        true,
		Name:           "threatName",
		ReadOnly:       true,
		Type:           "string",
	},
	"ThreatSeverity": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatSeverity",
		Description: `Severity associated with the threat; values are informational, low, medium,
high, critical.`,
		Exposed:  true,
		Name:     "threatSeverity",
		ReadOnly: true,
		Type:     "string",
	},
	"TlsVersion": {
		AllowedChoices: []string{},
		ConvertedName:  "TlsVersion",
		Description:    `TLS version associated with the session.`,
		Exposed:        true,
		Name:           "tlsVersion",
		ReadOnly:       true,
		Type:           "string",
	},
	"UrlCategory": {
		AllowedChoices: []string{},
		ConvertedName:  "UrlCategory",
		Description:    `URL category associated with the session (if applicable).`,
		Exposed:        true,
		Name:           "urlCategory",
		ReadOnly:       true,
		Type:           "string",
	},
	"VpcEndpoint": {
		AllowedChoices: []string{},
		ConvertedName:  "VpcEndpoint",
		Description:    `Service endpoint associated with the session.`,
		Exposed:        true,
		Name:           "vpcEndpoint",
		ReadOnly:       true,
		Type:           "string",
	},
}

// FirewallLogLowerCaseAttributesMap represents the map of attribute for FirewallLog.
var FirewallLogLowerCaseAttributesMap = map[string]elemental.AttributeSpecification{
	"xffip": {
		AllowedChoices: []string{},
		ConvertedName:  "XFFIP",
		Description: `The IP address of the user who requested the web page or the IP address of the
next to last device that the request traversed. If the request goes through one
or more proxies, load balancers, or other upstream devices, the firewall
displays the IP address of the most recent device.`,
		Exposed:  true,
		Name:     "XFFIP",
		ReadOnly: true,
		Type:     "string",
	},
	"action": {
		AllowedChoices: []string{},
		ConvertedName:  "Action",
		Description:    `Action taken for the session.`,
		Exposed:        true,
		Name:           "action",
		ReadOnly:       true,
		Type:           "string",
	},
	"app": {
		AllowedChoices: []string{},
		ConvertedName:  "App",
		Description:    `Application associated with the session.`,
		Exposed:        true,
		Name:           "app",
		ReadOnly:       true,
		Type:           "string",
	},
	"appcategory": {
		AllowedChoices: []string{},
		ConvertedName:  "AppCategory",
		Description:    `Application category associated with the session.`,
		Exposed:        true,
		Name:           "appCategory",
		ReadOnly:       true,
		Type:           "string",
	},
	"appsubcategory": {
		AllowedChoices: []string{},
		ConvertedName:  "AppSubcategory",
		Description:    `Application subcategory associated with the session.`,
		Exposed:        true,
		Name:           "appSubcategory",
		ReadOnly:       true,
		Type:           "string",
	},
	"bytesreceived": {
		AllowedChoices: []string{},
		ConvertedName:  "BytesReceived",
		Description:    `Number of bytes in the server-to-client direction of the session.`,
		Exposed:        true,
		Name:           "bytesReceived",
		ReadOnly:       true,
		Type:           "string",
	},
	"bytessent": {
		AllowedChoices: []string{},
		ConvertedName:  "BytesSent",
		Description:    `Number of bytes in the client-to-server direction of the session.`,
		Exposed:        true,
		Name:           "bytesSent",
		ReadOnly:       true,
		Type:           "string",
	},
	"chainstatus": {
		AllowedChoices: []string{},
		ConvertedName:  "ChainStatus",
		Description:    `Chain status of the session.`,
		Exposed:        true,
		Name:           "chainStatus",
		ReadOnly:       true,
		Type:           "string",
	},
	"cloudaccount": {
		AllowedChoices: []string{},
		ConvertedName:  "CloudAccount",
		Description:    `Cloud account associated with the session.`,
		Exposed:        true,
		Name:           "cloudAccount",
		ReadOnly:       true,
		Type:           "string",
	},
	"cloudregion": {
		AllowedChoices: []string{},
		ConvertedName:  "CloudRegion",
		Description:    `Cloud provider region associated with the session.`,
		Exposed:        true,
		Name:           "cloudRegion",
		ReadOnly:       true,
		Type:           "string",
	},
	"cloudtype": {
		AllowedChoices: []string{},
		ConvertedName:  "CloudType",
		Description:    `Cloud provider associated with the session.`,
		Exposed:        true,
		Name:           "cloudType",
		ReadOnly:       true,
		Type:           "string",
	},
	"destinationcountry": {
		AllowedChoices: []string{},
		ConvertedName:  "DestinationCountry",
		Description: `Destination country or Internal region for private addresses. Maximum length is
32 bytes.`,
		Exposed:  true,
		Name:     "destinationCountry",
		ReadOnly: true,
		Type:     "string",
	},
	"destinationip": {
		AllowedChoices: []string{},
		ConvertedName:  "DestinationIP",
		Description:    `Original session destination IP address.`,
		Exposed:        true,
		Name:           "destinationIP",
		ReadOnly:       true,
		Type:           "string",
	},
	"destinationport": {
		AllowedChoices: []string{},
		ConvertedName:  "DestinationPort",
		Description:    `Destination port utilized by the session.`,
		Exposed:        true,
		Name:           "destinationPort",
		ReadOnly:       true,
		Type:           "integer",
	},
	"firewallname": {
		AllowedChoices: []string{},
		ConvertedName:  "FirewallName",
		Description:    `Name of firewall that generated the log.`,
		Exposed:        true,
		Name:           "firewallName",
		ReadOnly:       true,
		Type:           "string",
	},
	"operationmode": {
		AllowedChoices: []string{},
		ConvertedName:  "OperationMode",
		Description:    `Operation mode of firewall that generated the log.`,
		Exposed:        true,
		Name:           "operationMode",
		ReadOnly:       true,
		Type:           "string",
	},
	"packetsreceived": {
		AllowedChoices: []string{},
		ConvertedName:  "PacketsReceived",
		Description:    `Number of server-to-client packets for the session.`,
		Exposed:        true,
		Name:           "packetsReceived",
		ReadOnly:       true,
		Type:           "string",
	},
	"packetssent": {
		AllowedChoices: []string{},
		ConvertedName:  "PacketsSent",
		Description:    `Number of client-to-server packets for the session.`,
		Exposed:        true,
		Name:           "packetsSent",
		ReadOnly:       true,
		Type:           "string",
	},
	"protocol": {
		AllowedChoices: []string{},
		ConvertedName:  "Protocol",
		Description:    `IP protocol associated with the session.`,
		Exposed:        true,
		Name:           "protocol",
		ReadOnly:       true,
		Type:           "string",
	},
	"proxytype": {
		AllowedChoices: []string{},
		ConvertedName:  "ProxyType",
		Description:    `Type of decryption proxy associated with the session.`,
		Exposed:        true,
		Name:           "proxyType",
		ReadOnly:       true,
		Type:           "string",
	},
	"rule": {
		AllowedChoices: []string{},
		ConvertedName:  "Rule",
		Description:    `Name of the rule that the session matched.`,
		Exposed:        true,
		Name:           "rule",
		ReadOnly:       true,
		Type:           "string",
	},
	"sessionendreason": {
		AllowedChoices: []string{},
		ConvertedName:  "SessionEndReason",
		Description: `The reason a session terminated. If the termination had multiple causes, this
field displays only the highest priority reason.`,
		Exposed:  true,
		Name:     "sessionEndReason",
		ReadOnly: true,
		Type:     "string",
	},
	"sni": {
		AllowedChoices: []string{},
		ConvertedName:  "Sni",
		Description:    `Server Name Indication (SNI) value for the session.`,
		Exposed:        true,
		Name:           "sni",
		ReadOnly:       true,
		Type:           "string",
	},
	"sourcecountry": {
		AllowedChoices: []string{},
		ConvertedName:  "SourceCountry",
		Description: `Source country or Internal region for private addresses; maximum length is 32
bytes.`,
		Exposed:  true,
		Name:     "sourceCountry",
		ReadOnly: true,
		Type:     "string",
	},
	"sourceip": {
		AllowedChoices: []string{},
		ConvertedName:  "SourceIP",
		Description:    `Original session source IP address.`,
		Exposed:        true,
		Name:           "sourceIP",
		ReadOnly:       true,
		Type:           "string",
	},
	"sourceport": {
		AllowedChoices: []string{},
		ConvertedName:  "SourcePort",
		Description:    `Source port utilized by the session.`,
		Exposed:        true,
		Name:           "sourcePort",
		ReadOnly:       true,
		Type:           "integer",
	},
	"threatcategory": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatCategory",
		Description: `Describes threat categories used to classify different types of threat
signatures.`,
		Exposed:  true,
		Name:     "threatCategory",
		ReadOnly: true,
		Type:     "string",
	},
	"threatdirection": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatDirection",
		Description:    `Indicates the direction of the attack, client-to-server or server-to-client.`,
		Exposed:        true,
		Name:           "threatDirection",
		ReadOnly:       true,
		Type:           "string",
	},
	"threatname": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatName",
		Description:    `Name of the threat signature that triggered the session.`,
		Exposed:        true,
		Name:           "threatName",
		ReadOnly:       true,
		Type:           "string",
	},
	"threatseverity": {
		AllowedChoices: []string{},
		ConvertedName:  "ThreatSeverity",
		Description: `Severity associated with the threat; values are informational, low, medium,
high, critical.`,
		Exposed:  true,
		Name:     "threatSeverity",
		ReadOnly: true,
		Type:     "string",
	},
	"tlsversion": {
		AllowedChoices: []string{},
		ConvertedName:  "TlsVersion",
		Description:    `TLS version associated with the session.`,
		Exposed:        true,
		Name:           "tlsVersion",
		ReadOnly:       true,
		Type:           "string",
	},
	"urlcategory": {
		AllowedChoices: []string{},
		ConvertedName:  "UrlCategory",
		Description:    `URL category associated with the session (if applicable).`,
		Exposed:        true,
		Name:           "urlCategory",
		ReadOnly:       true,
		Type:           "string",
	},
	"vpcendpoint": {
		AllowedChoices: []string{},
		ConvertedName:  "VpcEndpoint",
		Description:    `Service endpoint associated with the session.`,
		Exposed:        true,
		Name:           "vpcEndpoint",
		ReadOnly:       true,
		Type:           "string",
	},
}

// SparseFirewallLogsList represents a list of SparseFirewallLogs
type SparseFirewallLogsList []*SparseFirewallLog

// Identity returns the identity of the objects in the list.
func (o SparseFirewallLogsList) Identity() elemental.Identity {

	return FirewallLogIdentity
}

// Copy returns a pointer to a copy the SparseFirewallLogsList.
func (o SparseFirewallLogsList) Copy() elemental.Identifiables {

	copy := append(SparseFirewallLogsList{}, o...)
	return &copy
}

// Append appends the objects to the a new copy of the SparseFirewallLogsList.
func (o SparseFirewallLogsList) Append(objects ...elemental.Identifiable) elemental.Identifiables {

	out := append(SparseFirewallLogsList{}, o...)
	for _, obj := range objects {
		out = append(out, obj.(*SparseFirewallLog))
	}

	return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o SparseFirewallLogsList) List() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i]
	}

	return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o SparseFirewallLogsList) DefaultOrder() []string {

	return []string{}
}

// ToPlain returns the SparseFirewallLogsList converted to FirewallLogsList.
func (o SparseFirewallLogsList) ToPlain() elemental.IdentifiablesList {

	out := make(elemental.IdentifiablesList, len(o))
	for i := 0; i < len(o); i++ {
		out[i] = o[i].ToPlain()
	}

	return out
}

// Version returns the version of the content.
func (o SparseFirewallLogsList) Version() int {

	return 1
}

// SparseFirewallLog represents the sparse version of a firewalllog.
type SparseFirewallLog struct {
	// The IP address of the user who requested the web page or the IP address of the
	// next to last device that the request traversed. If the request goes through one
	// or more proxies, load balancers, or other upstream devices, the firewall
	// displays the IP address of the most recent device.
	XFFIP *string `json:"XFFIP,omitempty" msgpack:"XFFIP,omitempty" bson:"-" mapstructure:"XFFIP,omitempty"`

	// Action taken for the session.
	Action *string `json:"action,omitempty" msgpack:"action,omitempty" bson:"-" mapstructure:"action,omitempty"`

	// Application associated with the session.
	App *string `json:"app,omitempty" msgpack:"app,omitempty" bson:"-" mapstructure:"app,omitempty"`

	// Application category associated with the session.
	AppCategory *string `json:"appCategory,omitempty" msgpack:"appCategory,omitempty" bson:"-" mapstructure:"appCategory,omitempty"`

	// Application subcategory associated with the session.
	AppSubcategory *string `json:"appSubcategory,omitempty" msgpack:"appSubcategory,omitempty" bson:"-" mapstructure:"appSubcategory,omitempty"`

	// Number of bytes in the server-to-client direction of the session.
	BytesReceived *string `json:"bytesReceived,omitempty" msgpack:"bytesReceived,omitempty" bson:"-" mapstructure:"bytesReceived,omitempty"`

	// Number of bytes in the client-to-server direction of the session.
	BytesSent *string `json:"bytesSent,omitempty" msgpack:"bytesSent,omitempty" bson:"-" mapstructure:"bytesSent,omitempty"`

	// Chain status of the session.
	ChainStatus *string `json:"chainStatus,omitempty" msgpack:"chainStatus,omitempty" bson:"-" mapstructure:"chainStatus,omitempty"`

	// Cloud account associated with the session.
	CloudAccount *string `json:"cloudAccount,omitempty" msgpack:"cloudAccount,omitempty" bson:"-" mapstructure:"cloudAccount,omitempty"`

	// Cloud provider region associated with the session.
	CloudRegion *string `json:"cloudRegion,omitempty" msgpack:"cloudRegion,omitempty" bson:"-" mapstructure:"cloudRegion,omitempty"`

	// Cloud provider associated with the session.
	CloudType *string `json:"cloudType,omitempty" msgpack:"cloudType,omitempty" bson:"-" mapstructure:"cloudType,omitempty"`

	// Destination country or Internal region for private addresses. Maximum length is
	// 32 bytes.
	DestinationCountry *string `json:"destinationCountry,omitempty" msgpack:"destinationCountry,omitempty" bson:"-" mapstructure:"destinationCountry,omitempty"`

	// Original session destination IP address.
	DestinationIP *string `json:"destinationIP,omitempty" msgpack:"destinationIP,omitempty" bson:"-" mapstructure:"destinationIP,omitempty"`

	// Destination port utilized by the session.
	DestinationPort *int `json:"destinationPort,omitempty" msgpack:"destinationPort,omitempty" bson:"-" mapstructure:"destinationPort,omitempty"`

	// Name of firewall that generated the log.
	FirewallName *string `json:"firewallName,omitempty" msgpack:"firewallName,omitempty" bson:"-" mapstructure:"firewallName,omitempty"`

	// Operation mode of firewall that generated the log.
	OperationMode *string `json:"operationMode,omitempty" msgpack:"operationMode,omitempty" bson:"-" mapstructure:"operationMode,omitempty"`

	// Number of server-to-client packets for the session.
	PacketsReceived *string `json:"packetsReceived,omitempty" msgpack:"packetsReceived,omitempty" bson:"-" mapstructure:"packetsReceived,omitempty"`

	// Number of client-to-server packets for the session.
	PacketsSent *string `json:"packetsSent,omitempty" msgpack:"packetsSent,omitempty" bson:"-" mapstructure:"packetsSent,omitempty"`

	// IP protocol associated with the session.
	Protocol *string `json:"protocol,omitempty" msgpack:"protocol,omitempty" bson:"-" mapstructure:"protocol,omitempty"`

	// Type of decryption proxy associated with the session.
	ProxyType *string `json:"proxyType,omitempty" msgpack:"proxyType,omitempty" bson:"-" mapstructure:"proxyType,omitempty"`

	// Name of the rule that the session matched.
	Rule *string `json:"rule,omitempty" msgpack:"rule,omitempty" bson:"-" mapstructure:"rule,omitempty"`

	// The reason a session terminated. If the termination had multiple causes, this
	// field displays only the highest priority reason.
	SessionEndReason *string `json:"sessionEndReason,omitempty" msgpack:"sessionEndReason,omitempty" bson:"-" mapstructure:"sessionEndReason,omitempty"`

	// Server Name Indication (SNI) value for the session.
	Sni *string `json:"sni,omitempty" msgpack:"sni,omitempty" bson:"-" mapstructure:"sni,omitempty"`

	// Source country or Internal region for private addresses; maximum length is 32
	// bytes.
	SourceCountry *string `json:"sourceCountry,omitempty" msgpack:"sourceCountry,omitempty" bson:"-" mapstructure:"sourceCountry,omitempty"`

	// Original session source IP address.
	SourceIP *string `json:"sourceIP,omitempty" msgpack:"sourceIP,omitempty" bson:"-" mapstructure:"sourceIP,omitempty"`

	// Source port utilized by the session.
	SourcePort *int `json:"sourcePort,omitempty" msgpack:"sourcePort,omitempty" bson:"-" mapstructure:"sourcePort,omitempty"`

	// Describes threat categories used to classify different types of threat
	// signatures.
	ThreatCategory *string `json:"threatCategory,omitempty" msgpack:"threatCategory,omitempty" bson:"-" mapstructure:"threatCategory,omitempty"`

	// Indicates the direction of the attack, client-to-server or server-to-client.
	ThreatDirection *string `json:"threatDirection,omitempty" msgpack:"threatDirection,omitempty" bson:"-" mapstructure:"threatDirection,omitempty"`

	// Name of the threat signature that triggered the session.
	ThreatName *string `json:"threatName,omitempty" msgpack:"threatName,omitempty" bson:"-" mapstructure:"threatName,omitempty"`

	// Severity associated with the threat; values are informational, low, medium,
	// high, critical.
	ThreatSeverity *string `json:"threatSeverity,omitempty" msgpack:"threatSeverity,omitempty" bson:"-" mapstructure:"threatSeverity,omitempty"`

	// TLS version associated with the session.
	TlsVersion *string `json:"tlsVersion,omitempty" msgpack:"tlsVersion,omitempty" bson:"-" mapstructure:"tlsVersion,omitempty"`

	// URL category associated with the session (if applicable).
	UrlCategory *string `json:"urlCategory,omitempty" msgpack:"urlCategory,omitempty" bson:"-" mapstructure:"urlCategory,omitempty"`

	// Service endpoint associated with the session.
	VpcEndpoint *string `json:"vpcEndpoint,omitempty" msgpack:"vpcEndpoint,omitempty" bson:"-" mapstructure:"vpcEndpoint,omitempty"`

	ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparseFirewallLog returns a new  SparseFirewallLog.
func NewSparseFirewallLog() *SparseFirewallLog {
	return &SparseFirewallLog{}
}

// Identity returns the Identity of the sparse object.
func (o *SparseFirewallLog) Identity() elemental.Identity {

	return FirewallLogIdentity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *SparseFirewallLog) Identifier() string {

	return ""
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *SparseFirewallLog) SetIdentifier(id string) {

}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseFirewallLog) GetBSON() (any, error) {

	if o == nil {
		return nil, nil
	}

	s := &mongoAttributesSparseFirewallLog{}

	return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *SparseFirewallLog) SetBSON(raw bson.Raw) error {

	if o == nil {
		return nil
	}

	s := &mongoAttributesSparseFirewallLog{}
	if err := raw.Unmarshal(s); err != nil {
		return err
	}

	return nil
}

// Version returns the hardcoded version of the model.
func (o *SparseFirewallLog) Version() int {

	return 1
}

// ToPlain returns the plain version of the sparse model.
func (o *SparseFirewallLog) ToPlain() elemental.PlainIdentifiable {

	out := NewFirewallLog()
	if o.XFFIP != nil {
		out.XFFIP = *o.XFFIP
	}
	if o.Action != nil {
		out.Action = *o.Action
	}
	if o.App != nil {
		out.App = *o.App
	}
	if o.AppCategory != nil {
		out.AppCategory = *o.AppCategory
	}
	if o.AppSubcategory != nil {
		out.AppSubcategory = *o.AppSubcategory
	}
	if o.BytesReceived != nil {
		out.BytesReceived = *o.BytesReceived
	}
	if o.BytesSent != nil {
		out.BytesSent = *o.BytesSent
	}
	if o.ChainStatus != nil {
		out.ChainStatus = *o.ChainStatus
	}
	if o.CloudAccount != nil {
		out.CloudAccount = *o.CloudAccount
	}
	if o.CloudRegion != nil {
		out.CloudRegion = *o.CloudRegion
	}
	if o.CloudType != nil {
		out.CloudType = *o.CloudType
	}
	if o.DestinationCountry != nil {
		out.DestinationCountry = *o.DestinationCountry
	}
	if o.DestinationIP != nil {
		out.DestinationIP = *o.DestinationIP
	}
	if o.DestinationPort != nil {
		out.DestinationPort = *o.DestinationPort
	}
	if o.FirewallName != nil {
		out.FirewallName = *o.FirewallName
	}
	if o.OperationMode != nil {
		out.OperationMode = *o.OperationMode
	}
	if o.PacketsReceived != nil {
		out.PacketsReceived = *o.PacketsReceived
	}
	if o.PacketsSent != nil {
		out.PacketsSent = *o.PacketsSent
	}
	if o.Protocol != nil {
		out.Protocol = *o.Protocol
	}
	if o.ProxyType != nil {
		out.ProxyType = *o.ProxyType
	}
	if o.Rule != nil {
		out.Rule = *o.Rule
	}
	if o.SessionEndReason != nil {
		out.SessionEndReason = *o.SessionEndReason
	}
	if o.Sni != nil {
		out.Sni = *o.Sni
	}
	if o.SourceCountry != nil {
		out.SourceCountry = *o.SourceCountry
	}
	if o.SourceIP != nil {
		out.SourceIP = *o.SourceIP
	}
	if o.SourcePort != nil {
		out.SourcePort = *o.SourcePort
	}
	if o.ThreatCategory != nil {
		out.ThreatCategory = *o.ThreatCategory
	}
	if o.ThreatDirection != nil {
		out.ThreatDirection = *o.ThreatDirection
	}
	if o.ThreatName != nil {
		out.ThreatName = *o.ThreatName
	}
	if o.ThreatSeverity != nil {
		out.ThreatSeverity = *o.ThreatSeverity
	}
	if o.TlsVersion != nil {
		out.TlsVersion = *o.TlsVersion
	}
	if o.UrlCategory != nil {
		out.UrlCategory = *o.UrlCategory
	}
	if o.VpcEndpoint != nil {
		out.VpcEndpoint = *o.VpcEndpoint
	}

	return out
}

// DeepCopy returns a deep copy if the SparseFirewallLog.
func (o *SparseFirewallLog) DeepCopy() *SparseFirewallLog {

	if o == nil {
		return nil
	}

	out := &SparseFirewallLog{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *SparseFirewallLog.
func (o *SparseFirewallLog) DeepCopyInto(out *SparseFirewallLog) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy SparseFirewallLog: %s", err))
	}

	*out = *target.(*SparseFirewallLog)
}

type mongoAttributesFirewallLog struct {
}
type mongoAttributesSparseFirewallLog struct {
}
